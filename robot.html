<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1, user-scalable=no" />
<title>Sumo Robot Control — WebSocket</title>
<style>
  html,body{margin:0;padding:0;height:100%;width:100%;background:#0f1113;color:#fff;font-family:Arial,Helvetica,sans-serif;user-select:none; -webkit-user-select:none; overflow:hidden;}
  .container{display:grid;grid-template-columns:35% 15% 50%;height:100vh;gap:10px;padding:10px;box-sizing:border-box;}
  .left{display:flex;justify-content:center;align-items:center;}
  .speed-slider{writing-mode:bt-lr;-webkit-appearance:slider-vertical;width:120px;height:90%;padding:18px;touch-action:none;}
  .center{display:flex;justify-content:center;align-items:center;}
  .stop-btn{width:130px;height:130px;border-radius:50%;background:linear-gradient(180deg,#ff486d 0%,#c32a4a 100%);border:none;font-size:24px;color:#fff;box-shadow:0 8px 20px rgba(195,42,74,0.45);}
  .stop-btn:active{transform:scale(0.96);}
  .right{display:flex;justify-content:center;align-items:center;}
  .joystick{position:relative;width:90%;height:90%;background:rgba(255,255,255,0.02);border-radius:50%;touch-action:none;-webkit-tap-highlight-color:transparent;}
  .thumb{position:absolute;width:60px;height:60px;background:#3db3ff;border-radius:50%;transform:translate(-50%,-50%);top:50%;left:50%;transition:left 0s,top 0s;}
  .arrow-label{position:absolute;font-size:24px;color:#fff;pointer-events:none;opacity:0.85;}
  .arrow-label.up{top:6%;left:50%;transform:translateX(-50%);}
  .arrow-label.down{bottom:6%;left:50%;transform:translateX(-50%);}
  .arrow-label.left{left:6%;top:50%;transform:translateY(-50%);}
  .arrow-label.right{right:6%;top:50%;transform:translateY(-50%);}
  .info{position:absolute;left:8px;top:8px;font-size:12px;opacity:0.8;color:#ccc;}
  input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:30px;height:30px;background:#3db3ff;border-radius:50%;border:2px solid #0f1113;}
  .status { position: absolute; right: 8px; top: 8px; font-size:12px; opacity:0.9; color:#cfc; }
</style>
</head>
<body>
<div class="info">Dead zone: 20px • WebSocket port: 81</div>
<div class="status" id="status">WS: connecting…</div>

<div class="container">
  <div class="left">
    <input id="speedSlider" class="speed-slider" type="range" min="0" max="255" value="150" />
  </div>

  <div class="center">
    <button id="stopBtn" class="stop-btn">STOP</button>
  </div>

  <div class="right">
    <div id="joystick" class="joystick" role="application" aria-label="Joystick">
      <div id="thumb" class="thumb"></div>
      <div class="arrow-label up">&#9650;</div>
      <div class="arrow-label down">&#9660;</div>
      <div class="arrow-label left">&#9664;</div>
      <div class="arrow-label right">&#9654;</div>
    </div>
  </div>
</div>

<script>
/* Config */
const DEAD_ZONE = 20;          // px
const ARDUINO_WS_PORT = 81;    // must match Arduino server port

/* DOM */
const joystick = document.getElementById('joystick');
const thumb = document.getElementById('thumb');
const speedSlider = document.getElementById('speedSlider');
const stopBtn = document.getElementById('stopBtn');
const statusEl = document.getElementById('status');

let ws;
let dragging = false;
let lastDir = "";
let lastSend = 0;

/* Build websocket address from hostname (works if phone uses board as AP or same LAN) */
function buildWsUrl() {
  return "ws://10.77.0.10:81";
}


/* Connect websocket */
function connectWS() {
  const url = buildWsUrl();
  statusEl.textContent = `WS: ${url}`;
  try {
    ws = new WebSocket(url);
  } catch (e) {
    statusEl.textContent = 'WS: error';
    console.error(e);
    return;
  }

  ws.onopen = () => {
    statusEl.textContent = 'WS: connected';
  };
  ws.onclose = () => {
    statusEl.textContent = 'WS: closed';
    // attempt reconnect after a short delay
    setTimeout(connectWS, 1000);
  };
  ws.onerror = (e) => {
    statusEl.textContent = 'WS: error';
  };
  ws.onmessage = (ev) => {
    // optional: handle status messages from Arduino
    // console.log('rx', ev.data);
  };
}

/* send commands */
function sendMove(dir) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  const speed = parseInt(speedSlider.value) || 150;
  // Format: move:<dir>:<speed>
  const msg = `move:${dir}:${speed}`;
  if (msg === lastSentMsg()) return; // avoid duplicates
  ws.send(msg);
  lastDir = dir;
}
function sendStop() {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send('stop');
  lastDir = "";
}
function lastSentMsg() {
  // simple helper — combine lastDir with speed
  const speed = parseInt(speedSlider.value) || 150;
  return lastDir ? `move:${lastDir}:${speed}` : 'stop';
}

/* Direction detection */
function getDirection(x, y) {
  const rect = joystick.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  const dx = x - cx;
  const dy = y - cy;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist < DEAD_ZONE) return "none";
  if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? "right" : "left";
  return dy < 0 ? "forward" : "backward";
}

/* Thumb move */
function moveThumb(x, y) {
  const rect = joystick.getBoundingClientRect();
  const cx = rect.width/2;
  const cy = rect.height/2;
  const localX = x - rect.left;
  const localY = y - rect.top;
  const dx = localX - cx;
  const dy = localY - cy;
  const radius = rect.width/2 - 30;
  const dist = Math.min(Math.sqrt(dx*dx + dy*dy), radius);
  const angle = Math.atan2(dy, dx);
  const left = cx + dist * Math.cos(angle);
  const top = cy + dist * Math.sin(angle);
  thumb.style.left = left + 'px';
  thumb.style.top = top + 'px';
}
function resetThumb() {
  thumb.style.left = '50%';
  thumb.style.top = '50%';
}

/* Pointer handlers */
function pointerStart(clientX, clientY) {
  dragging = true;
  const dir = getDirection(clientX, clientY);
  if (dir !== "none") sendMove(dir);
  moveThumb(clientX, clientY);
}
function pointerMove(clientX, clientY) {
  if (!dragging) return;
  const dir = getDirection(clientX, clientY);
  if (dir === "none") {
    sendStop();
  } else {
    // send only on direction change to reduce messages
    if (dir !== lastDir) sendMove(dir);
  }
  moveThumb(clientX, clientY);
}
function pointerEnd() {
  dragging = false;
  resetThumb();
  sendStop();
}

/* Event wiring: use pointer events if available */
if (window.PointerEvent) {
  joystick.addEventListener('pointerdown', e => { e.preventDefault(); joystick.setPointerCapture(e.pointerId); pointerStart(e.clientX, e.clientY); });
  joystick.addEventListener('pointermove', e => { e.preventDefault(); pointerMove(e.clientX, e.clientY); });
  joystick.addEventListener('pointerup', e => { e.preventDefault(); joystick.releasePointerCapture(e.pointerId); pointerEnd(); });
  joystick.addEventListener('pointercancel', e => { e.preventDefault(); pointerEnd(); });
} else {
  joystick.addEventListener('touchstart', e => { e.preventDefault(); const t = e.touches[0]; pointerStart(t.clientX, t.clientY); }, {passive:false});
  joystick.addEventListener('touchmove', e => { e.preventDefault(); const t = e.touches[0]; pointerMove(t.clientX, t.clientY); }, {passive:false});
  joystick.addEventListener('touchend', e => { e.preventDefault(); pointerEnd(); }, {passive:false});
  joystick.addEventListener('mousedown', e => { e.preventDefault(); pointerStart(e.clientX, e.clientY); });
  window.addEventListener('mousemove', e => { if (dragging) pointerMove(e.clientX, e.clientY); });
  window.addEventListener('mouseup', e => { if (dragging) pointerEnd(); });
}

/* Stop button */
stopBtn.addEventListener('touchstart', e => { e.preventDefault(); sendStop(); }, {passive:false});
stopBtn.addEventListener('click', () => sendStop());

/* Slider immediate update if moving */
speedSlider.addEventListener('input', () => {
  if (lastDir !== "") {
    // send updated speed with current direction
    sendMove(lastDir);
  }
});

/* Prevent page scrolling while dragging */
document.body.addEventListener('touchmove', function(e) { if (dragging) e.preventDefault(); }, { passive:false });

/* Start websocket connection */
connectWS();

</script>
</body>
</html>

